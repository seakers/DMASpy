from logging import Logger

import simpy
from simpy import Environment
from src.network.messages import Message


class Component:
    def __init__(self, env, name, power, energy_stored, energy_capacity,
                 data_rate, data_stored, data_capacity, status=False):
        """
        Abstract component class. Describes a generic component that can generate or consume data or power when it is
        on. It can also store power or data up to a determined capacity
        :param env: Simulation environment
        :param name: Name of the component
        :param power: Power generated by the component if it is a positive value. Power consumed if negative
        :param energy_stored: Energy stored in this component at any given time
        :param energy_capacity: Energy storage capacity for this component
        :param data_rate: Data rate generated by the component
        :param data_stored: Data volume stored in component at any given time
        :param data_capacity: Data volume capacity for this component
        :param status: Initial state of the component. If true, the component is on. If false, the component if off.
        """
        self.name = name
        self.status = status
        self.health = True

        self.power = power
        if energy_capacity > 0:
            self.energy_stored = simpy.Container(env, energy_capacity, energy_stored)
        self.energy_capacity = energy_capacity

        self.data_rate = data_rate
        if data_capacity > 0:
            self.data_stored = simpy.Container(env, data_capacity, data_stored)
        self.data_capacity = data_capacity

    def is_on(self):
        """
        Returns whether the component is on or not
        :return:
        """
        return self.status

    def turn_on(self):
        """
        Turns on component only if component is not failing
        :return:
        """
        if self.health:
            self.status = True
        else:
            self.status = False

    def turn_off(self):
        """
        Turns off component
        :return:
        """
        self.status = False

    def __str__(self):
        return f"{(self.name).capitalize()}"


class OnBoardComputer(Component):
    def __init__(self, env, power, memory_size):
        """
        On-board computer in charge of storing long-term data as well as pre-processed measurement data.
        Must always be on. Cannot be turned off unless the component fails
        :param env: Simulation environment
        :param power: Power requirement
        :param memory_size: Internal memory capacity
        """
        super().__init__(env=env, name='memory', power=-power, energy_stored=0,
                         energy_capacity=0, data_rate=0, data_stored=0,
                         data_capacity=memory_size, status=True)


class Transmitter(Component):
    def __init__(self, env, power, max_data_rate, buffer_size, num_channels=1):
        """
        Transmitter in charge of sending messages to other agents. Turns on automatically when sending a message and
        turns off once the transmission is complete.
        :param env: Simulation environment
        :param power: Power requirement
        :param max_data_rate: Maximum data-rate
        :param buffer_size: Outgoing buffer size
        :param num_channels: Number of outgoing communication channels available
        """
        super().__init__(env=env, name='transmitter', power=-power, energy_stored=0, energy_capacity=0,
                         data_rate=0, data_stored=0, data_capacity=buffer_size,
                         status=False)
        self.max_data_rate = max_data_rate
        self.num_channels = num_channels
        self.channels = simpy.Resource(env, num_channels)

    def send_message(self, env: Environment, msg: Message, logger: Logger):
        '''
        Attempts to send a message to the destination specified in the message.
        It waits for the transmitter to have enough room in its buffer to move message from
        the agent's on-board computer to the transmitter. It then requests a transmission and
        reception channel and waits until they are granted. The function then finally waits for
        the receiver's buffer to become available to start the transmission.
        :param env: Environment being used
        :param msg: Message being sent
        :param logger: System logger used for tracing agent's actions
        :return:
        '''
        dst = msg.dst
        receiver = dst.receiver

        if msg.data_rate > self.max_data_rate:
            # The message being sent requests a data-rate higher than the maximum available
            # for this transmitter. Dropping packet.
            logger.debug(f'T{env.now}:\tThe message being sent requests a data-rate higher than '
                         f'the maximum available for this transmitter. Dropping packet.')
            return

        try:
            # request transmitter to allocate outgoing message into its buffer
            logger.debug(f'T{env.now}:\tMoving message from internal memory to outgoing buffer...')
            yield self.data_stored.put(msg.size)
            logger.debug(f'T{env.now}:\tMessage successfully moved to outgoing buffer.')
        except simpy.Interrupt:
            logger.debug(f'T{env.now}:\tCould not move message to outgoing buffer.')
            return

        transmission_channel_established = False
        reception_channel_established = False
        channels_established = False
        transmission_started = False
        try:
            # request transmission and reception channels
            req_trs = self.channels.request()
            req_rcr = receiver.channels.request()

            logger.debug(f'T{env.now}:\tRequesting transmission channel...')
            yield req_trs
            transmission_channel_established = True
            logger.debug(f'T{env.now}:\tTransmission channel obtained! Requesting reception channel...')
            yield req_rcr
            reception_channel_established = True
            logger.debug(f'T{env.now}:\tReception channel obtained! Connection established.')

            channels_established = True

            # request receiver to allocate outgoing message into its buffer
            logger.debug(f'T{env.now}:\tRequesting receiver to allocate message size in buffer...')
            yield receiver.data_stored.put(msg.size)
            logger.debug(f'T{env.now}:\tBuffer memory allocated! Starting transmission...')

            # starting transmission
            transmission_started = True

            msg.start_time = env.now
            receiver.inbox.put(msg)
            self.turn_on()

            if self.is_on():
                self.data_rate += msg.data_rate
                yield env.timeout(msg.size / msg.data_rate - (env.now - msg.start_time))
                logger.debug(f'T{env.now}:\tTransmission complete!')
            else:
                # Transmitter is not on after being told to do so. Must be faulty. Dropping packet
                yield self.data_stored.get(msg.size)
                logger.debug(f'T{env.now}:\tTransmitter will not turn on. Must be faulty. Dropping packet.')

            # end transmission
            logger.debug(f'T{env.now}:\tReleasing transmission channel...')
            self.channels.release(req_trs)
            logger.debug(f'T{env.now}:\tReleasing reception channel...')
            receiver.channels.release(req_rcr)

            logger.debug(f'T{env.now}:\tTransmission protocol complete!')

        except simpy.Interrupt:
            logger.debug(f'T{env.now}:\tTransmission Interrupted. Dropping packet.')
            if not channels_established and not transmission_started:
                # transmission interrupted during channel request
                if transmission_channel_established:
                    logger.debug(f'T{env.now}:\tReleasing transmission channel.')
                    self.channels.release(req_trs)
                if reception_channel_established:
                    logger.debug(f'T{env.now}:\tReleasing reception channel...')
                    receiver.channels.release(req_rcr)
                self.data_stored.get(msg.size)
                return
            elif channels_established and not transmission_started:
                # transmission interrupted while waiting for receiver buffer allocation
                logger.debug(f'T{env.now}:\tReleasing transmission and reception channels...')
                self.channels.release(req_trs)
                receiver.channels.release(req_rcr)
                logger.debug(f'T{env.now}:\tDropping packet.')
                self.data_stored.get(msg.size)
                return
            else:
                # transmission interrupted while broadcasting
                # release channels used
                logger.debug(f'T{env.now}:\tReleasing transmission and reception channels...')
                self.channels.release(req_trs)
                receiver.channels.release(req_rcr)

                # drop packet and turn off transmitter
                logger.debug(f'T{env.now}:\tDropping packet.')
                self.data_stored.get(msg.size - (env.now - msg.start_time) * msg.data_rate)
                self.data_rate -= msg.data_rate
                if self.channels.count == 0:
                    logger.debug(f'T{env.now}:\tNo more messages available for transmission. Turning off transmitter...')
                    self.turn_off()
                return
        return


class Receiver(Component):
    def __init__(self, env, power, max_data_rate, buffer_size, num_channels=1):
        """
        Receiver component in charge of listening for incoming messages, receiving their transmission, and forwarding
        new messages to internal memory of the agent's on-board computer
        :param env: Simulated environment
        :param power: Power requirement
        :param max_data_rate: Maximum data rate for message reception
        :param buffer_size: Incoming buffer size
        :param num_channels: Number of incoming communication channels available
        """
        super().__init__(env=env, name='receiver', power=-power, energy_stored=0, energy_capacity=0,
                         data_rate=0, data_stored=0, data_capacity=buffer_size,
                         status=True)
        self.max_data_rate = max_data_rate
        self.num_channels = num_channels
        self.channels = simpy.Resource(env, num_channels)
        self.inbox = simpy.Store(env)
        self.received_messages = []

    def receive(self, env, msg, on_board_computer: OnBoardComputer, logger: Logger):
        '''
        Receives a message from another agent. Memory has already been allocated by the transmitter. Receiver waits for
        transmission to finish and then moves message from its buffer to the agent's internal memory. If interrupted it
        drops the packet being received.
        :param env: Environment being used
        :param msg: Message being received
        :param on_board_computer: Agent's on-board computer with available memory
        :param logger: System logger used for tracing agent's actions
        :return:
        '''
        try:
            # TODO only allow for message reception when component is on
            if self.data_rate + msg.data_rate > self.max_data_rate:
                # The message being received requests a data-rate higher than the maximum
                # available for this transmitter. Dropping packet.
                logger.debug(f'T{env.now}:\tThe message being received requests a data-rate higher than the '
                             f'maximum available for this transmitter. Dropping packet.')
                return

            self.data_rate += msg.data_rate

            logger.debug(f'T{env.now}:\tStarting reception...')
            yield env.timeout(msg.size / msg.data_rate)
            logger.debug(f'T{env.now}:\tReception complete! Awaiting ...')

            msg.reception_time = env.now
            self.received_messages.append(msg)

            logger.debug(f'T{env.now}:\tRequesting on-board computer to allocate message size in internal memory...')
            yield on_board_computer.data_stored.put(msg.size)
            logger.debug(f'T{env.now}:\tInternal memory allocated! Removing message from receiver buffer...')

            self.received_messages.remove(msg)
            self.data_stored.get(msg.size)

        except simpy.Interrupt:
            self.data_stored.get(msg.size)
            return


class PowerGenerator(Component):
    def __init__(self, env, power_generation):
        """
        Generic power generation component. Supplies power to the rest of the agent's components
        :param env: Simulated environment
        :param power_generation: Maximum power to be generated
        """
        super().__init__(env, name='generator', power=0, energy_stored=0,
                         energy_capacity=0, data_rate=0, data_stored=0, data_capacity=0,
                         status=False)
        self.max_power_generation = power_generation

    def turn_on_generator(self, power_out):
        if power_out <= 0:
            raise ArithmeticError("Power generated must be greater than 0")
        if self.health:
            if power_out <= self.max_power_generation:
                self.power = power_out
            else:
                self.power = self.max_power_generation

    def turn_off_generator(self):
        self.power = 0
        self.turn_off()

class Battery(Component):
    def __init__(self, env, max_power_generation, energy_capacity, dod):
        """
        Battery component in charge of storing energy and providing power when actuated
        :param env: Simulation environment
        :param max_power_generation: Maximum power provided by battery when turned on
        :param energy_capacity: Maximum power storage capacity of the battery
        :param dod: Maximum depth-of-discharge allowed.
            TODO: if charge is below DOD then set battery health to False. Should prevent it from charging in the future.
        """
        super().__init__(env=env, name='battery', power=0,
                         energy_stored=energy_capacity, energy_capacity=energy_capacity,
                         data_rate=0, data_stored=0, data_capacity=0, status=False)
        self.charging = False
        self.max_power_generation = max_power_generation
        self.dod = dod
        if not (0 <= dod <= 1):
            raise IOError("Depth-of-Discharge can only be a value between 0 and 1.")

    def is_charging(self):
        return self.charging

    def turn_on_generator(self, power_out):
        if power_out <= 0:
            raise ArithmeticError("Power generated must be greater than 0")
        if self.health:
            if power_out <= self.max_power_generation:
                self.power = power_out
            else:
                self.power = self.max_power_generation

    def turn_off_generator(self):
        self.power = 0
        self.turn_off()
