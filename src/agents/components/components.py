from logging import Logger

import simpy
from simpy import Environment

from src.network.messages import Message


class Component:
    def __init__(self, env, name, power, energy_stored, energy_capacity,
                 data_rate, data_stored, data_capacity, status=False):
        """
        Abstract component class. Describes a generic component that can generate or consume data or power when it is
        on. It can also store power or data up to a determined capacity
        :param env: Simulation environment
        :param name: Name of the component
        :param power: Power generated by the component if it is a positive value. Power consumed if negative
        :param energy_stored: Energy stored in this component at any given time
        :param energy_capacity: Energy storage capacity for this component
        :param data_rate: Data rate generated by the component
        :param data_stored: Data volume stored in component at any given time
        :param data_capacity: Data volume capacity for this component
        :param status: Initial state of the component. If true, the component is on. If false, the component if off.
        """
        self.name = name
        self.status = status
        self.health = True

        self.power = power
        if energy_capacity > 0:
            self.energy_stored = simpy.Container(env, energy_capacity, energy_stored)
        self.energy_capacity = energy_capacity

        self.data_rate = data_rate
        if data_capacity > 0:
            self.data_stored = simpy.Container(env, data_capacity, data_stored)
        self.data_capacity = data_capacity

    def is_on(self):
        """
        Returns whether the component is on or not
        :return:
        """
        return self.status

    def turn_on(self):
        """
        Turns on component only if component is not failing
        :return:
        """
        if self.health:
            self.status = True
        else:
            self.status = False

    def turn_off(self):
        """
        Turns off component
        :return:
        """
        self.status = False

    def __str__(self):
        return f"{(self.name).capitalize()}"


class OnBoardComputer(Component):
    def __init__(self, env, power, memory_size):
        """
        On-board computer in charge of storing long-term data as well as pre-processed measurement data.
        Must always be on. Cannot be turned off unless the component fails
        :param env: Simulation environment
        :param power: Power requirement
        :param memory_size: Internal memory capacity
        """
        super().__init__(env=env, name='memory', power=-power, energy_stored=0,
                         energy_capacity=0, data_rate=0, data_stored=0,
                         data_capacity=memory_size, status=True)

    def from_dict(d, env):
        power = d.get('power', None)
        memory_size = d.get('memorySize', None)

        if power is None or memory_size is None:
            raise Exception('Input Error: JSON input file must contain power and memory information for on-board computer.')

        return OnBoardComputer(env, power, memory_size)

class Transmitter(Component):
    def __init__(self, env, power, max_data_rate, buffer_size, num_channels=1):
        """
        Transmitter in charge of sending messages to other agents. Turns on automatically when sending a message and
        turns off once the transmission is complete.
        :param env: Simulation environment
        :param power: Power requirement
        :param max_data_rate: Maximum data-rate
        :param buffer_size: Outgoing buffer size
        :param num_channels: Number of outgoing communication channels available
        """
        super().__init__(env=env, name='transmitter', power=-power, energy_stored=0, energy_capacity=0,
                         data_rate=0, data_stored=0, data_capacity=buffer_size,
                         status=False)
        self.max_data_rate = max_data_rate
        self.num_channels = num_channels
        self.channels = simpy.Resource(env, num_channels)
        self.transmitting = False

    def from_dict(d, env):
        power = d.get('power', None)
        max_data_rate = d.get('maxDataRate', None)
        buffer_size = d.get('bufferSize', None)
        num_channels = d.get('numChannels', None)

        if num_channels is None:
            num_channels = 1
        if power is None or max_data_rate is None or buffer_size:
            raise Exception('Input Error: JSON input file must contain power, max data rate, and buffer size for transmitter.')

        return Transmitter(env, power, max_data_rate, buffer_size, num_channels)

    def is_transmitting(self):
        return self.transmitting

    def turn_off(self):
        super().turn_off()
        self.transmitting = False

    def allocate_buffer_memory(self, env: Environment, msg: Message, parent_agent):
        if msg.data_rate + self.data_rate > self.max_data_rate:
            # The message being sent requests a data-rate higher than the maximum available
            # for this transmitter. Dropping packet.
            raise simpy.Interrupt('The message being sent requests a data-rate higher than '
                                  f'the maximum available for this transmitter.')

        msg.timeout_start = env.now

        try:
            # request transmitter to allocate outgoing message into its buffer
            parent_agent.logger.debug(f'T{env.now}:\tMoving message from internal memory to outgoing buffer...')

            parent_agent.update_system()
            yield self.data_stored.put(msg.size)
            parent_agent.update_system()

            parent_agent.logger.debug(f'T{env.now}:\tMessage successfully moved to outgoing buffer.')
        except simpy.Interrupt:
            parent_agent.logger.debug(f'T{env.now}:\tCould not move message to outgoing buffer.')

    def request_channel(self, env: Environment, msg: Message, parent_agent):
        # unpack message
        dst = msg.dst
        receiver = dst.platform.receiver

        # initialize indicators
        transmission_channel_established = False
        reception_channel_established = False

        # request transmission and reception channels
        req_trs = self.channels.request()
        req_rcr = receiver.channels.request()

        try:
            parent_agent.logger.debug(f'T{env.now}:\tRequesting transmission channel...')
            yield req_trs
            transmission_channel_established = True

            parent_agent.logger.debug(f'T{env.now}:\tTransmission channel obtained! Requesting reception channel...')
            yield req_rcr
            reception_channel_established = True

            parent_agent.logger.debug(f'T{env.now}:\tReception channel obtained! Connection established.')

            # request receiver to allocate outgoing message into its buffer
            parent_agent.logger.debug(f'T{env.now}:\tRequesting receiver to allocate message size in buffer...')
            dst.update_system()

            parent_agent.update_system()
            yield receiver.data_stored.put(msg.size)
            parent_agent.update_system()

            parent_agent.logger.debug(f'T{env.now}:\tReceiver buffer memory allocated! Starting transmission...')

        except simpy.Interrupt as i:
            if transmission_channel_established:
                parent_agent.logger.debug(f'T{env.now}:\t{i.cause} Releasing transmission channel...')
                self.channels.release(req_trs)
            if reception_channel_established:
                parent_agent.logger.debug(f'T{env.now}:\t{i.cause} Releasing reception channel...')
                receiver.channels.release(req_rcr)

        return req_trs, req_rcr

    def transmit_message(self, req_trs, req_rcr, env: Environment, msg: Message, parent_agent):
        '''
        Attempts to send a message to the destination specified in the message.
        It waits for the transmitter to have enough room in its buffer to move message from
        the agent's on-board computer to the transmitter. It then requests a transmission and
        reception channel and waits until they are granted. The function then finally waits for
        the receiver's buffer to become available to start the transmission.
        :param env: Environment being used
        :param msg: Message being sent
        :param logger: System logger used for tracing agent's actions
        :return:
        '''
        dst = msg.dst
        receiver = dst.platform.receiver

        try:
            # place message in receivers inbox
            yield receiver.inbox.put(msg)

            # begin transmission
            self.transmitting = True
            self.data_rate += msg.data_rate

            if msg.transmission_start == -1:
                msg.transmission_start = env.now

            parent_agent.update_system()
            yield env.timeout(msg.size / msg.data_rate - (env.now - msg.transmission_start))
            parent_agent.update_system()

            msg.transmission_end_event.succeed()
            msg.transmission_end = env.now
            parent_agent.logger.debug(f'T{env.now}:\tTransmission complete!')

            # end transmission
            parent_agent.logger.debug(f'T{env.now}:\tReleasing transmission and reception channels...')
            self.channels.release(req_trs)
            receiver.channels.release(req_rcr)

            parent_agent.logger.debug(f'T{env.now}:\tTransmission protocol complete!')

        except simpy.Interrupt as i:
            # transmission interrupted while broadcasting
            # release channels used
            parent_agent.logger.debug(f'T{env.now}:\tReleasing transmission and reception channels...')
            self.channels.release(req_trs)
            receiver.channels.release(req_rcr)

            # stopping transmission event
            msg.transmission_end_event.succeed()

    def send_message(self, env: Environment, msg: Message, parent_agent):
        allocate_memory = None
        request_channel = None
        transmit = None

        try:
            allocate_memory = env.process(self.allocate_buffer_memory(env, msg, parent_agent))
            yield allocate_memory

            request_channel = env.process(self.request_channel(env, msg, parent_agent))
            req_trs, req_rcr = yield request_channel

            transmit = env.process(self.transmit_message(req_trs, req_rcr, env, msg, parent_agent))
            yield transmit
            return

        except simpy.Interrupt as i:
            if allocate_memory is not None and not allocate_memory.triggered:
                parent_agent.logger.debug(f'T{env.now}:\tInterrupting memory allocation...')
                allocate_memory.interrupt(i)
            if request_channel is not None and not request_channel.triggered:
                parent_agent.logger.debug(f'T{env.now}:\tInterrupting channel requests...')
                request_channel.interrupt(i)
            if transmit is not None and not transmit.triggered:
                parent_agent.logger.debug(f'T{env.now}:\tInterrupting transmission...')
                transmit.interrupt(i)

            # drop packet
            parent_agent.logger.debug(f'T{env.now}:\tDropping packet...')

            if msg.transmission_start < 0:
                yield self.data_stored.get(msg.size)
            else:
                rem_size = msg.size - (env.now - msg.transmission_start) * msg.data_rate
                if rem_size > 0:
                    yield self.data_stored.get(rem_size)

            if self.transmitting:
                # reducing data-rate
                self.data_rate -= msg.data_rate
                self.transmitting = False


class Receiver(Component):
    def __init__(self, env, power, max_data_rate, buffer_size, num_channels=1):
        """
        Receiver component in charge of listening for incoming messages, receiving their transmission, and forwarding
        new messages to internal memory of the agent's on-board computer
        :param env: Simulated environment
        :param power: Power requirement
        :param max_data_rate: Maximum data rate for message reception
        :param buffer_size: Incoming buffer size
        :param num_channels: Number of incoming communication channels available
        """
        super().__init__(env=env, name='receiver', power=-power, energy_stored=0, energy_capacity=0,
                         data_rate=0, data_stored=0, data_capacity=buffer_size,
                         status=True)
        self.max_data_rate = max_data_rate
        self.num_channels = num_channels
        self.channels = simpy.Resource(env, num_channels)
        self.inbox = simpy.Store(env)
        self.received_messages = []

    def from_dict(d, env):
        power = d.get('power', None)
        max_data_rate = d.get('maxDataRate', None)
        buffer_size = d.get('bufferSize', None)
        num_channels = d.get('numChannels', None)

        if num_channels is None:
            num_channels = 1
        if power is None or max_data_rate is None or buffer_size:
            raise Exception('Input Error: JSON input file must contain power, max data rate, and buffer size for receiver.')

        return Receiver(env, power, max_data_rate, buffer_size, num_channels)

    def receive(self, env, msg, parent_agent):
        '''
        Receives a message from another agent. Memory has already been allocated by the transmitter. Receiver waits for
        transmission to finish and then moves message from its buffer to the agent's internal memory. If interrupted it
        drops the packet being received.
        :param env: Environment being used
        :param msg: Message being received
        :param on_board_computer: Agent's on-board computer with available memory
        :param logger: System logger used for tracing agent's actions
        :return:
        '''
        try:
            # TODO only allow for message reception when component is on
            if self.data_rate + msg.data_rate > self.max_data_rate:
                # The message being received requests a data-rate higher than the maximum
                # available for this transmitter. Dropping packet.
                parent_agent.logger.debug(f'T{env.now}:\tThe message being received requests a data-rate higher than the '
                             f'maximum available for this transmitter. Dropping packet.')
                return

            self.data_rate += msg.data_rate

            msg.reception_start = env.now
            yield msg.transmission_end_event
            msg.reception_end = env.now

            data_received = (msg.reception_end - msg.reception_start) * msg.data_rate
            if data_received < msg.size:
                # insufficient data was received. wait for timeout
                parent_agent.logger.debug(f'T{env.now}:\tStopped receiving transmission from A{msg.src.unique_id}.')
                self.data_rate -= msg.data_rate
                t_left = msg.reception_start + msg.timeout - env.now
                yield env.timeout(t_left*2)
            else:
                # successfully received the complete message
                self.received_messages.append(msg)
                parent_agent.logger.debug(f'T{env.now}:\tReception complete! ')
                self.received_messages.remove(msg)

        except simpy.Interrupt:
            self.data_stored.get(msg.size)
            return


class PowerGenerator(Component):
    def __init__(self, env, power_generation):
        """
        Generic power generation component. Supplies power to the rest of the agent's components
        :param env: Simulated environment
        :param power_generation: Maximum power to be generated
        """
        super().__init__(env, name='generator', power=0, energy_stored=0,
                         energy_capacity=0, data_rate=0, data_stored=0, data_capacity=0,
                         status=False)
        self.max_power_generation = power_generation

    def turn_on_generator(self, power_out):
        if power_out <= 0:
            raise ArithmeticError("Power generated must be greater than 0")
        if self.health:
            if power_out <= self.max_power_generation:
                self.power = power_out
            else:
                self.power = self.max_power_generation
            self.turn_on()

    def turn_off_generator(self):
        self.power = 0
        self.turn_off()


class SolarPanelArray(PowerGenerator):
    def __init__(self, env, power_generation):
        super().__init__(env, power_generation)
        self.eclipse = False
        self.name = 'solar_generator'

    def from_dict(d, env):
        power_generation = d.get('maxPowerGeneration', None)

        if power_generation is None:
            raise Exception('Input Error: JSON input file must contain maximum power generation for solar panels.')
        
        return SolarPanelArray(env, power_generation)

    def turn_on_generator(self, power_out):
        if power_out <= 0:
            raise ArithmeticError("Power generated must be greater than 0")
        if self.health and not self.eclipse:
            if power_out <= self.max_power_generation:
                self.power = power_out
            else:
                self.power = self.max_power_generation
        self.turn_on()

    def in_eclipse(self):
        return self.eclipse

    def enter_eclipse(self):
        self.eclipse = True
        self.power = 0

    def exit_eclipse(self):
        self.eclipse = False
        if self.is_on():
            self.power = self.max_power_generation

class Battery(Component):
    def __init__(self, env, max_power_generation, energy_capacity, dod=1, initial_charge=1):
        """
        Battery component in charge of storing energy and providing power when actuated
        :param env: Simulation environment
        :param max_power_generation: Maximum power provided by battery when turned on
        :param energy_capacity: Maximum power storage capacity of the battery
        :param dod: Maximum depth-of-discharge allowed.
        :param initial_charge: Initial charge
            TODO: if charge is below DOD then set battery health to False. Should prevent it from charging in the future.
        """
        super().__init__(env=env, name='battery', power=0,
                         energy_stored=initial_charge*energy_capacity, energy_capacity=energy_capacity,
                         data_rate=0, data_stored=0, data_capacity=0, status=False)

        self.charging = False
        self.max_power_generation = max_power_generation
        self.dod = dod
        self.can_hold_charge = True
        if not (0 <= dod <= 1):
            raise IOError("Depth-of-Discharge can only be a value between 0 and 1.")
        elif not (0 <= initial_charge <= 1):
            raise IOError("Initial charge can only be a value between 0 and 1.")

    def from_dict(d, env):
        max_power_generation = d.get('maxPowerGeneration', None)
        energy_capacity = d.get('energyStorageCapacity', None)
        dod = d.get('depthOfDischarge', None)
        initial_charge = d.get('initialCharge', None)

        if dod is None:
            dod = 1
        if initial_charge is None:
            initial_charge = 1

        if max_power_generation is None or energy_capacity is None:
            raise Exception('Input Error: JSON input file must contain at least maximum power generation and energy storage capacity for battery.')

        return Battery(env, max_power_generation, energy_capacity, dod, initial_charge)

    def update_charge(self, power_in, dt):
        power_charging = 0
        if self.is_charging() and power_in >= 0:
            power_charging += power_in
        if self.is_on():
            power_charging -= self.power

        if power_charging * dt > 0:
            dif = self.energy_capacity - self.energy_stored.level
            if dif < power_charging * dt:
                self.energy_stored.put(dif)
            else:
                self.energy_stored.put(power_charging * dt)
        elif power_charging * dt < 0:
            if self.energy_stored.level > 0:
                if -power_charging * dt >= self.energy_stored.level:
                    self.energy_stored.get(self.energy_stored.level)
                    self.turn_off_generator()
                else:
                    self.energy_stored.get(-power_charging * dt)
            else:
                self.turn_off_generator()

    def turn_on_charge(self):
        if self.can_hold_charge:
            self.charging = True

    def turn_off_charge(self):
        self.charging = False

    def is_charging(self):
        return self.charging

    def turn_on_generator(self, power_out):
        if power_out <= 0:
            raise ArithmeticError("Power generated must be greater than 0")
        if self.health and self.energy_stored.level > 0:
            if power_out <= self.max_power_generation:
                self.power = power_out
            else:
                self.power = self.max_power_generation
            self.turn_on()

    def turn_off_generator(self):
        self.power = 0
        self.turn_off()
