from logging import Logger

import simpy
from simpy import Environment
from src.network.messages import Message


class Component:
    def __init__(self, env, name, power, energy_stored, energy_capacity,
                 data_rate, data_stored, data_capacity, status=False):
        """
        Abstract component class. Describes a generic component that can generate or consume data or power when it is
        on. It can also store power or data up to a determined capacity
        :param env: Simulation environment
        :param name: Name of the component
        :param power: Power generated by the component if it is a positive value. Power consumed if negative
        :param energy_stored: Energy stored in this component at any given time
        :param energy_capacity: Energy storage capacity for this component
        :param data_rate: Data rate generated by the component
        :param data_stored: Data volume stored in component at any given time
        :param data_capacity: Data volume capacity for this component
        :param status: Initial state of the component. If true, the component is on. If false, the component if off.
        """
        self.name = name
        self.status = status
        self.health = True

        self.power = power
        if energy_capacity > 0:
            self.energy_stored = simpy.Container(env, energy_capacity, energy_stored)
        self.energy_capacity = energy_capacity

        self.data_rate = data_rate
        if data_capacity > 0:
            self.data_stored = simpy.Container(env, data_capacity, data_stored)
        self.data_capacity = data_capacity

    def is_on(self):
        """
        Returns whether the component is on or not
        :return:
        """
        return self.status

    def turn_on(self):
        """
        Turns on component only if component is not failing
        :return:
        """
        if self.health:
            self.status = True
        else:
            self.status = False

    def turn_off(self):
        """
        Turns off component
        :return:
        """
        self.status = False

    def __str__(self):
        return f"{(self.name).capitalize()}"


class OnBoardComputer(Component):
    def __init__(self, env, power, memory_size):
        """
        On-board computer in charge of storing long-term data as well as pre-processed measurement data.
        Must always be on. Cannot be turned off unless the component fails
        :param env: Simulation environment
        :param power: Power requirement
        :param memory_size: Internal memory capacity
        """
        super().__init__(env=env, name='memory', power=-power, energy_stored=0,
                         energy_capacity=0, data_rate=0, data_stored=0,
                         data_capacity=memory_size, status=True)


class Transmitter(Component):
    def __init__(self, env, power, max_data_rate, buffer_size, num_channels=1):
        """
        Transmitter in charge of sending messages to other agents. Turns on automatically when sending a message and
        turns off once the transmission is complete.
        :param env: Simulation environment
        :param power: Power requirement
        :param max_data_rate: Maximum data-rate
        :param buffer_size: Outgoing buffer size
        :param num_channels: Number of outgoing communication channels available
        """
        super().__init__(env=env, name='transmitter', power=-power, energy_stored=0, energy_capacity=0,
                         data_rate=0, data_stored=0, data_capacity=buffer_size,
                         status=False)
        self.max_data_rate = max_data_rate
        self.num_channels = num_channels
        self.channels = simpy.Resource(env, num_channels)

    def allocate_buffer_memory(self, env: Environment, msg: Message, logger: Logger):
        if msg.data_rate + self.data_rate > self.max_data_rate:
            # The message being sent requests a data-rate higher than the maximum available
            # for this transmitter. Dropping packet.
            raise simpy.Interrupt('The message being sent requests a data-rate higher than '
                                  f'the maximum available for this transmitter.')

        msg.start_time = env.now

        try:
            # request transmitter to allocate outgoing message into its buffer
            logger.debug(f'T{env.now}:\tMoving message from internal memory to outgoing buffer...')
            yield self.data_stored.put(msg.size)
            logger.debug(f'T{env.now}:\tMessage successfully moved to outgoing buffer.')
        except simpy.Interrupt:
            logger.debug(f'T{env.now}:\tCould not move message to outgoing buffer.')

    def request_channel(self, env: Environment, msg: Message, logger: Logger):
        # unpack message
        dst = msg.dst
        receiver = dst.receiver

        # initialize indicators
        transmission_channel_established = False
        reception_channel_established = False

        # request transmission and reception channels
        req_trs = self.channels.request()
        req_rcr = receiver.channels.request()

        try:
            logger.debug(f'T{env.now}:\tRequesting transmission channel...')
            yield req_trs
            transmission_channel_established = True

            logger.debug(f'T{env.now}:\tTransmission channel obtained! Requesting reception channel...')
            yield req_rcr
            reception_channel_established = True

            logger.debug(f'T{env.now}:\tReception channel obtained! Connection established.')

            # request receiver to allocate outgoing message into its buffer
            logger.debug(f'T{env.now}:\tRequesting receiver to allocate message size in buffer...')
            yield receiver.data_stored.put(msg.size)
            logger.debug(f'T{env.now}:\tReceiver buffer memory allocated! Starting transmission...')

        except simpy.Interrupt as i:
            if transmission_channel_established:
                logger.debug(f'T{env.now}:\t{i.cause} Releasing transmission channel...')
                self.channels.release(req_trs)
            if reception_channel_established:
                logger.debug(f'T{env.now}:\t{i.cause} Releasing reception channel...')
                receiver.channels.release(req_rcr)

        return req_trs, req_rcr

    def transmit_message(self, req_trs, req_rcr, env: Environment, msg: Message, logger: Logger):
        '''
        Attempts to send a message to the destination specified in the message.
        It waits for the transmitter to have enough room in its buffer to move message from
        the agent's on-board computer to the transmitter. It then requests a transmission and
        reception channel and waits until they are granted. The function then finally waits for
        the receiver's buffer to become available to start the transmission.
        :param env: Environment being used
        :param msg: Message being sent
        :param logger: System logger used for tracing agent's actions
        :return:
        '''
        dst = msg.dst
        receiver = dst.receiver

        try:
            # place message in receivers inbox
            yield receiver.inbox.put(msg)

            # begin transmission
            self.data_rate += msg.data_rate
            yield env.timeout(msg.size / msg.data_rate - (env.now - msg.start_time))
            logger.debug(f'T{env.now}:\tTransmission complete!')

            # end transmission
            logger.debug(f'T{env.now}:\tReleasing transmission and reception channels...')
            self.channels.release(req_trs)
            receiver.channels.release(req_rcr)
            self.data_rate -= msg.data_rate

            logger.debug(f'T{env.now}:\tTransmission protocol complete!')

        except simpy.Interrupt as i:
            # transmission interrupted while broadcasting
            # release channels used
            logger.debug(f'T{env.now}:\tReleasing transmission and reception channels...')
            self.channels.release(req_trs)
            receiver.channels.release(req_rcr)

            # drop packet and turn off transmitter
            logger.debug(f'T{env.now}:\tDropping packet...')
            yield self.data_stored.get(msg.size - (env.now - msg.start_time) * msg.data_rate)
            self.data_rate -= msg.data_rate

    def send_message(self, env: Environment, msg: Message, logger: Logger):
        allocate_memory = None
        request_channel = None
        transmit = None

        try:
            allocate_memory = env.process(self.allocate_buffer_memory(env, msg, logger))
            yield allocate_memory

            request_channel = env.process(self.request_channel(env, msg, logger))
            req_trs, req_rcr = yield request_channel

            transmit = env.process(self.transmit_message(req_trs, req_rcr, env, msg, logger))
            yield transmit
            return

        except simpy.Interrupt as i:
            if allocate_memory.triggered:
                # deallocate memory
                logger.debug(f'T{env.now}:\tRemoving message from outgoing buffer.')
                yield self.data_stored.get(msg.size)

            if allocate_memory is not None and not allocate_memory.triggered:
                allocate_memory.interrupt(i)
            elif request_channel is not None and not request_channel.triggered:
                request_channel.interrupt(i)
            elif transmit is not None and not transmit.triggered:
                transmit.interrupt(i)

class Receiver(Component):
    def __init__(self, env, power, max_data_rate, buffer_size, num_channels=1):
        """
        Receiver component in charge of listening for incoming messages, receiving their transmission, and forwarding
        new messages to internal memory of the agent's on-board computer
        :param env: Simulated environment
        :param power: Power requirement
        :param max_data_rate: Maximum data rate for message reception
        :param buffer_size: Incoming buffer size
        :param num_channels: Number of incoming communication channels available
        """
        super().__init__(env=env, name='receiver', power=-power, energy_stored=0, energy_capacity=0,
                         data_rate=0, data_stored=0, data_capacity=buffer_size,
                         status=True)
        self.max_data_rate = max_data_rate
        self.num_channels = num_channels
        self.channels = simpy.Resource(env, num_channels)
        self.inbox = simpy.Store(env)
        self.received_messages = []

    def receive(self, env, msg, on_board_computer: OnBoardComputer, logger: Logger):
        '''
        Receives a message from another agent. Memory has already been allocated by the transmitter. Receiver waits for
        transmission to finish and then moves message from its buffer to the agent's internal memory. If interrupted it
        drops the packet being received.
        :param env: Environment being used
        :param msg: Message being received
        :param on_board_computer: Agent's on-board computer with available memory
        :param logger: System logger used for tracing agent's actions
        :return:
        '''
        try:
            # TODO only allow for message reception when component is on
            if self.data_rate + msg.data_rate > self.max_data_rate:
                # The message being received requests a data-rate higher than the maximum
                # available for this transmitter. Dropping packet.
                logger.debug(f'T{env.now}:\tThe message being received requests a data-rate higher than the '
                             f'maximum available for this transmitter. Dropping packet.')
                return

            self.data_rate += msg.data_rate

            logger.debug(f'T{env.now}:\tStarting reception...')
            yield env.timeout(msg.size / msg.data_rate)
            logger.debug(f'T{env.now}:\tReception complete! Awaiting ...')

            msg.reception_time = env.now
            self.received_messages.append(msg)

            logger.debug(f'T{env.now}:\tRequesting on-board computer to allocate message size in internal memory...')
            yield on_board_computer.data_stored.put(msg.size)
            logger.debug(f'T{env.now}:\tInternal memory allocated! Removing message from receiver buffer...')

            self.received_messages.remove(msg)
            self.data_stored.get(msg.size)

        except simpy.Interrupt:
            self.data_stored.get(msg.size)
            return


class PowerGenerator(Component):
    def __init__(self, env, power_generation):
        """
        Generic power generation component. Supplies power to the rest of the agent's components
        :param env: Simulated environment
        :param power_generation: Maximum power to be generated
        """
        super().__init__(env, name='generator', power=0, energy_stored=0,
                         energy_capacity=0, data_rate=0, data_stored=0, data_capacity=0,
                         status=False)
        self.max_power_generation = power_generation

    def turn_on_generator(self, power_out):
        if power_out <= 0:
            raise ArithmeticError("Power generated must be greater than 0")
        if self.health:
            if power_out <= self.max_power_generation:
                self.power = power_out
            else:
                self.power = self.max_power_generation
            self.turn_on()

    def turn_off_generator(self):
        self.power = 0
        self.turn_off()


class Battery(Component):
    def __init__(self, env, max_power_generation, energy_capacity, dod=1, initial_charge=1):
        """
        Battery component in charge of storing energy and providing power when actuated
        :param env: Simulation environment
        :param max_power_generation: Maximum power provided by battery when turned on
        :param energy_capacity: Maximum power storage capacity of the battery
        :param dod: Maximum depth-of-discharge allowed.
        :param initial_charge: Initial charge
            TODO: if charge is below DOD then set battery health to False. Should prevent it from charging in the future.
        """
        super().__init__(env=env, name='battery', power=0,
                         energy_stored=initial_charge*energy_capacity, energy_capacity=energy_capacity,
                         data_rate=0, data_stored=0, data_capacity=0, status=False)

        self.charging = False
        self.max_power_generation = max_power_generation
        self.dod = dod
        if not (0 <= dod <= 1):
            raise IOError("Depth-of-Discharge can only be a value between 0 and 1.")
        elif not (0 <= initial_charge <= 1):
            raise IOError("Initial charge can only be a value between 0 and 1.")

    def turn_on_charge(self):
        self.charging = True

    def turn_off_charge(self):
        self.charging = False

    def is_charging(self):
        return self.charging

    def turn_on_generator(self, power_out):
        if power_out <= 0:
            raise ArithmeticError("Power generated must be greater than 0")
        if self.health:
            if power_out <= self.max_power_generation:
                self.power = power_out
            else:
                self.power = self.max_power_generation
            self.turn_on()

    def turn_off_generator(self):
        self.power = 0
        self.turn_off()
