#### ENV

from concurrent.futures import ThreadPoolExecutor
import os
# os.environ['PYTHONASYNCIODEBUG'] = '0'
import asyncio
import json
import logging
import random
import time
from urllib import request
import zmq.asyncio
from modules.environment import EclipseEventModule, GPAccessEventModule, GndStatAccessEventModule, AgentAccessEventModule
from orbitdata import OrbitData

from messages import BroadcastTypes, RequestTypes
from modules.module import  Module
from modules.environment import EnvironmentModuleTypes, TicRequestModule
from utils import Container, SimClocks

"""
--------------------------------------------------------
 ____                                                                         __      
/\  _`\                    __                                                /\ \__   
\ \ \L\_\    ___   __  __ /\_\  _ __   ___     ___     ___ ___      __    ___\ \ ,_\  
 \ \  _\L  /' _ `\/\ \/\ \\/\ \/\`'__\/ __`\ /' _ `\ /' __` __`\  /'__`\/' _ `\ \ \/  
  \ \ \L\ \/\ \/\ \ \ \_/ |\ \ \ \ \//\ \L\ \/\ \/\ \/\ \/\ \/\ \/\  __//\ \/\ \ \ \_ 
   \ \____/\ \_\ \_\ \___/  \ \_\ \_\\ \____/\ \_\ \_\ \_\ \_\ \_\ \____\ \_\ \_\ \__\
    \/___/  \/_/\/_/\/__/    \/_/\/_/ \/___/  \/_/\/_/\/_/\/_/\/_/\/____/\/_/\/_/\/__/                                                         
 ____                                           
/\  _`\                                         
\ \,\L\_\     __   _ __   __  __     __   _ __  
 \/_\__ \   /'__`\/\`'__\/\ \/\ \  /'__`\/\`'__\
   /\ \L\ \/\  __/\ \ \/ \ \ \_/ |/\  __/\ \ \/ 
   \ `\____\ \____\\ \_\  \ \___/ \ \____\\ \_\ 
    \/_____/\/____/ \/_/   \/__/   \/____/ \/_/                                                                                                                                                   
--------------------------------------------------------
"""

def count_number_of_subroutines(module: Module):
    count = module.NUMBER_OF_TIMED_COROUTINES
    for submodule in module.submodules:
        count += count_number_of_subroutines(submodule)
    return count

def is_port_in_use(port: int) -> bool:
    import socket
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex(('localhost', port)) == 0

class EnvironmentServer(Module):
    ENVIRONMENT_SERVER_NAME = 'ENV'

    def __init__(self, scenario_dir, agent_name_list: list, duration, clock_type: SimClocks = SimClocks.REAL_TIME, simulation_frequency: float = -1) -> None:
        super().__init__(EnvironmentServer.ENVIRONMENT_SERVER_NAME, n_timed_coroutines=1)
        # Constants
        self.AGENT_NAME_LIST = []                                       # List of names of agent present in the simulation
        self.NUMBER_AGENTS = len(agent_name_list)                       # Number of agents present in the simulation
        self.NUMBER_OF_TIMED_COROUTINES_AGENTS = 0                      # Number of timed co-routines to be performed by other agents

        for agent_name in agent_name_list:
            self.AGENT_NAME_LIST.append(agent_name)

        # simulation start and end tracking lists
        self.alive_subscribers = []
        self.offline_subscribers = []

        # simulation clock constants
        self.CLOCK_TYPE = clock_type                                    # Clock type being used in this simulation
        self.DURATION = duration                                        # Duration of simulation in simulation-time

        self.SIMULATION_FREQUENCY = None
        if self.CLOCK_TYPE == SimClocks.REAL_TIME:
            self.SIMULATION_FREQUENCY = 1
        elif self.CLOCK_TYPE == SimClocks.REAL_TIME_FAST:
            self.SIMULATION_FREQUENCY = simulation_frequency            # Ratio of simulation-time seconds to real-time seconds
        elif self.CLOCK_TYPE != SimClocks.SERVER_STEP:
            raise Exception(f'Simulation clock of type {clock_type.value} not yet supported')
        
        if simulation_frequency < 0 and self.CLOCK_TYPE == SimClocks.REAL_TIME_FAST:
            raise Exception('Simulation frequency needed to initiate simulation with a REAL_TIME_FAST clock.')

        # set up submodules
        self.submodules = [ TicRequestModule(self), 
                            EclipseEventModule(self), 
                            # GPAccessEventModule(self),
                            GndStatAccessEventModule(self),
                            AgentAccessEventModule(self)
                          ]
        
        # set up results dir
        self.SCENARIO_RESULTS_DIR, self.ENVIRONMENT_RESULTS_DIR = self.set_up_results_directory(scenario_dir)

        # set up loggers
        [self.message_logger, self.request_logger, self.state_logger, self.actions_logger] = self.set_up_loggers()

        # propagate orbit and coverage information
        self.orbit_data = OrbitData.from_directory(scenario_dir)

        print('Environment Initialized!')

    async def live(self):
        """
        MAIN FUNCTION 
        executes event loop for ayncronous processes within the environment
        """
        # Activate 
        await self.activate()

        # Run simulation
        await self.run()

    async def activate(self):
        """
        Initiates and executes commands that are thread-sensitive but that must be performed before the simulation starts.
        """
        self.log('Starting activation routine...', level=logging.INFO)
        
        # activate network ports
        self.log('Configuring network ports...', level=logging.INFO)
        await self.network_config()
        self.log('Network configuration completed!', level=logging.INFO)

        # Wait for agents to initialize their own network ports
        self.log(f"Waiting for {self.NUMBER_AGENTS} to initiate...", level=logging.INFO)
        subscriber_to_port_map =await self.sync_agents()
        self.log(f"All subscribers initalized! Starting simulation...", level=logging.INFO)
        
        # broadcasting simulation start
        await self.broadcast_sim_start(subscriber_to_port_map)

        self.log(f'Activating environment submodules...')
        await super().activate()
        self.log('Environment Activated!', level=logging.INFO)
    
    async def run(self):        
        """
        Performs simulation actions.

        Runs every module owned by the agent. Stops when one of the modules goes off-line, completes its run() routines, 
        or the environment sends a simulation end broadcast.
        """  
        # begin simulation
        self.log(f"Starting simulation...", level=logging.INFO)
        await super().run()

    async def shut_down(self):
        """
        Terminate processes 
        """
        self.log(f"Shutting down...", level=logging.INFO)

        # broadcast simulation end
        # await asyncio.sleep(random.random())
        await self.broadcast_sim_end()

        # close network ports  
        self.log(f"Closing all network sockets...") 
        self.publisher.close()
        self.reqservice.close()
        self.context.term()
        self.log(f"Network sockets closed.", level=logging.INFO)
        
        self.log(f"Simulation done, good night!", level=logging.INFO)

    """
    --------------------
    CO-ROUTINES AND TASKS
    --------------------
    """
    async def coroutines(self):
        """
        Executes list of coroutine tasks to be excuted by the environment. These coroutine task incluide:
            1- 'sim_end_timer': counts down to the end of the simulation
            2- 'request_handler': listens to 'reqservice' port and handles agent requests being sent
            3- 'broadcast_handler': receives broadcast requests and publishes them to all agents
        """
        sim_end_timer = asyncio.create_task(self.sim_wait(self.DURATION))
        request_handler = asyncio.create_task(self.request_handler())
        broadcast_handler = asyncio.create_task(self.broadcast_handler())

        await sim_end_timer
        request_handler.cancel()
        broadcast_handler.cancel()
        await request_handler
        await broadcast_handler
        self.log(f"Simulation time completed!", level=logging.INFO)

    async def internal_message_handler(self, msg):
        """
        Handles message intended for this module and performs actions accordingly.
        """
        try:
            dst_name = msg['dst']
            if dst_name != self.name:
                await self.put_message(msg)
            else:
                # if the message is of type broadcast, send to broadcast handler
                msg_type = msg['@type']
                if 'REQUEST' not in msg_type:
                    if (BroadcastTypes[msg_type] is BroadcastTypes.TIC_EVENT
                    or BroadcastTypes[msg_type] is BroadcastTypes.ECLIPSE_EVENT
                    or BroadcastTypes[msg_type] is BroadcastTypes.GS_ACCESS_EVENT
                    or BroadcastTypes[msg_type] is BroadcastTypes.GP_ACCESS_EVENT
                    or BroadcastTypes[msg_type] is BroadcastTypes.AGENT_ACCESS_EVENT):

                        await self.publisher_queue.put(msg)
                elif RequestTypes[msg_type] is RequestTypes.TIC_REQUEST:
                    # if an submodule sends a tic request, forward to tic request submodule
                    msg['dst'] = EnvironmentModuleTypes.TIC_REQUEST_MODULE
                    await self.put_message(msg)

                # else, dump
                return
        except asyncio.CancelledError:
            return

    async def request_handler(self):
        """
        Listens to 'reqservice' socket and handles agent requests accordingly. List of supported requests:
            1- tic_request: agents ask to be notified when a certain time has passed in the environment's clock    
            2- agent_access_request: agent asks the enviroment if the agent is capable of accessing another agent at the current simulation time
            3- gp_access_request: agent asks the enviroment if the agent is capable of accessing a ground point at the current simulation time
            4- gs_access_request: agent asks the enviroment if the agent is capable of accessing a ground station at the current simulation time
            5- agent_information_request: agent asks for information regarding its current position, velocity, and eclipse at the current simulation time
            6- observation_request: agent requests environment information regarding a the state of a ground point at the current simulation time
            7- agent_end_confirmation: agent notifies the environment that it has successfully terminated its operations

        Only tic request create future broadcast tasks. The rest require an immediate response from the environment.
        """
        async def request_worker(request):
            # check request message format
            if not RequestTypes.format_check(request):
                # if request does not match any of the standard request format, dump and continue
                self.log(f'Request does not match the standard format for a request message. Dumping request...')
                await self.reqservice.send_string('')
                return
    
            # unpackage message type and handle accordingly 
            req_type = request.get('@type')
            req_type = RequestTypes[req_type]

            if req_type is RequestTypes.TIC_REQUEST:
                # send reception confirmation to agent
                await self.reqservice.send_string('')

                # schedule tic request
                t_req = request.get('t')
                self.log(f'Received tic request for t_req={t_req}')

                # change source and destination to internal modules
                request['src'] = self.name
                request['dst'] = EnvironmentModuleTypes.TIC_REQUEST_MODULE.name

                # send to internal message router for forwarding
                self.put_message(request)

            # elif req_type is RequestTypes.AGENT_ACCESS_REQUEST:
            #     # unpackage message
            #     src = request['src']
            #     target = request['target']
                                
            #     # query agent access database
            #     self.orbit_data[src].isl_data

                
                
            #     await self.reqservice.send_string('')
            #     pass
            
            # elif req_type is RequestTypes.GP_ACCESS_REQUEST:
            #     await self.reqservice.send_string('')
            #     pass

            # elif req_type is RequestTypes.GS_ACCESS_REQUEST:
            #     await self.reqservice.send_string('')
            #     pass

            # elif req_type is RequestTypes.AGENT_INFO_REQUEST:
            #     await self.reqservice.send_string('')
            #     pass

            # elif req_type is RequestTypes.OBSERVATION_REQUEST:
            #     await self.reqservice.send_string('')
            #     pass

            # elif req_type is RequestTypes.AGENT_END_CONFIRMATION:
            #     # register that agent node has gone offline mid-simulation
            #     # (this agent node won't be considered when broadcasting simulation end)
            #     src = request['src']

            #     if src not in self.offline_subscribers:
            #         self.offline_subscribers.append(src)

            else:
                # if request type is not supported, dump and ignore message
                self.log(f'Request of type {req_type.value} not yet supported. Dumping request.')
                self.reqservice.send_string('')
                return

        try:            
            # with ThreadPoolExecutor() as executor:
            # TODO see how to improve performance by handling requests in parallel using multithreading
            while True:
                # listen for requests
                self.log('Waiting for agent requests...')
                req_str = await self.reqservice.recv_json()
                self.log(f'Request received!')
                
                # convert request to json
                req = json.loads(req_str)

                # handle request
                # executor.submit( request_worker(req) )
                await request_worker(req)

        except asyncio.CancelledError:
            return

    async def broadcast_handler(self):
        """
        Listens to internal message inbox to see if any submodule wishes to broadcast information to all agents.
        Broadcast types supported:
            1- 'tic': communicates the current environment clock
            2- 'eclipse_event': communicates which agents just entered or exited eclipse
            3- 'access_event': communicates when an agent just started or stopped accessing a ground point or another agent

            TODO: Add measurement requests from the ground?
        """
        try:
            while True:
                msg = await self.publisher_queue.get()

                if not BroadcastTypes.format_check(msg):
                    # if broadcast task does not meet the desired format, reject and dump
                    self.log('Broadcast task did not meet format specifications. Task dumped.')
                    return

                # change from internal message to external message
                msg['src'] = self.name
                msg['dst'] = 'all'
                msg_type = msg['@type']

                self.log(f'Broadcast task of type {msg_type} received! Publishing to all agents...')

                if BroadcastTypes[msg_type] is BroadcastTypes.TIC_EVENT:
                    t_next = msg['server_clock']
                    self.log(f'Updating internal clock to t={t_next}')
                    await self.sim_time.set_level(t_next)

                elif (BroadcastTypes[msg_type] is BroadcastTypes.ECLIPSE_EVENT
                     or BroadcastTypes[msg_type] is BroadcastTypes.GS_ACCESS_EVENT
                     or BroadcastTypes[msg_type] is BroadcastTypes.AGENT_ACCESS_EVENT):
                    msg['dst'] = msg['agent']
                    msg.pop('agent')
                
                else:
                    raise Exception(f'Broadcast task of type {msg_type} not yet supported. Dumping task...')

                # broadcast message
                self.log('Awaiting access to publisher socket...')
                await self.publisher_lock.acquire()
                self.log('Access to publisher socket acquired.')
                msg_json = json.dumps(msg)
                await self.publisher.send_json(msg_json)
                self.log('Broadcast sent')
                self.publisher_lock.release()
        except asyncio.CancelledError:
            return
        finally:
            if self.publisher_lock.locked():
                self.publisher_lock.release()

    """
    --------------------
    HELPING FUNCTIONS
    --------------------    
    """

    async def network_config(self):
        """
        Creates communication sockets and binds this environment to them.

        'publisher': socket in charge of broadcasting messages to all agents in the simulation
        'reqservice': socket in charge of receiving and answering requests from agents. These request can range from:
            1- sync_requests: agents confirm their activation and await a synchronized simulation start message
            2- tic_requests: agents ask to be notified when a certain time has passed in the environment's clock
            3- agent_information_request: agent asks for information regarding its current position, velocity, and eclipse
            4- observation_request: agent requests environment information regarding a the state of a ground point
        """
        # Activate network ports
        self.context = zmq.asyncio.Context()
    
        # Assign ports to sockets
        ## Set up socket to broadcast information to agents
        self.environment_port_number = '5561'
        if is_port_in_use(int(self.environment_port_number)):
            raise Exception(f"{self.environment_port_number} port already in use")
        self.publisher = self.context.socket(zmq.PUB)                   
        self.publisher.sndhwm = 1100000                                 ## set SNDHWM, so we don't drop messages for slow subscribers
        self.publisher.bind(f"tcp://*:{self.environment_port_number}")
        self.publisher_lock = asyncio.Lock()
        self.publisher_queue = asyncio.Queue()

        ## Set up socket to receive synchronization and measurement requests from agents
        self.request_port_number = '5562'
        if is_port_in_use(int(self.request_port_number)):
            raise Exception(f"{self.request_port_number} port already in use")
        self.reqservice = self.context.socket(zmq.REP)
        self.reqservice.bind(f"tcp://*:{self.request_port_number}")

    async def sync_agents(self):
        """
        Awaits for all other agents to undergo their initialization and activation routines and to become online. Once they do, 
        they will reach out to the environment through its 'reqservice' socket and subscribe to future broadcasts from the 
        environment's 'publisher' socket.

        The environment will then create a ledger mapping which agents are assigned to which ports. This ledger will later be 
        broadcasted to all agents.
        """

        # wait for agents to synchronize
        subscriber_to_port_map = dict()
        while len(self.alive_subscribers) < self.NUMBER_AGENTS:
            # wait for synchronization request
            msg_str = await self.reqservice.recv_json() 
            msg = json.loads(msg_str)
            msg_type = msg['@type']
            if RequestTypes[msg_type] != RequestTypes.SYNC_REQUEST or msg.get('port') is None:
                continue
            
            msg_src = msg.get('src', None)
            src_port = msg.get('port')
            self.NUMBER_OF_TIMED_COROUTINES_AGENTS += msg.get('n_coroutines')

            self.log(f'Received sync request from {msg_src}! Checking if already synchronized...', level=logging.INFO) 

            # log subscriber confirmation
            for agent_name in self.AGENT_NAME_LIST:
                if (agent_name in msg_src) and (agent_name not in self.alive_subscribers):
                    self.alive_subscribers.append(agent_name)
                    self.log(f"{agent_name} is now synchronized to environment ({len(self.alive_subscribers)}/{self.NUMBER_AGENTS}).")
                    
                    subscriber_to_port_map[msg_src] = src_port
                    break
                elif (agent_name in self.alive_subscribers):
                    self.log(f"{agent_name} is already synchronized to environment ({len(self.alive_subscribers)}/{self.NUMBER_AGENTS}).")
                elif (msg_src not in self.AGENT_NAME_LIST):
                    self.log(f"{agent_name} agent node not in list of agents for this environment ({len(self.alive_subscribers)}/{self.NUMBER_AGENTS}).")
                    
            # send synchronization reply
            await self.reqservice.send_string('')

        # self.NUMBER_OF_TIMED_COROUTINES = count_number_of_subroutines(self)

        return subscriber_to_port_map
                    
    async def broadcast_sim_start(self, subscriber_to_port_map):
        """
        Broadcasts simulation start to all agents subscribed to this environment.
        Simulation start message also contains a ledger that maps agent names to ports to be connected to for inter-agent
        communications. This message also contains information about the clock-type being used in this simulation.
        """
        # create message
        msg_dict = dict()
        msg_dict['src'] = self.name
        msg_dict['dst'] = 'ALL'
        msg_dict['@type'] = BroadcastTypes.SIM_START_EVENT.name
        
        # include subscriber-to-port map to message
        msg_dict['port_map'] = subscriber_to_port_map
        
        # include clock information to message
        clock_info = dict()
        clock_info['@type'] = self.CLOCK_TYPE.name
        if self.CLOCK_TYPE == SimClocks.REAL_TIME or self.CLOCK_TYPE == SimClocks.REAL_TIME_FAST:
            clock_info['freq'] = self.SIMULATION_FREQUENCY
            self.sim_time = 0
        else:
            self.sim_time = Container()
        msg_dict['clock_info'] = clock_info

        # package message and broadcast
        msg_json = json.dumps(msg_dict)
        await self.publisher.send_json(msg_json)

        # log simulation start time
        self.START_TIME = time.perf_counter()

        # initiate tic request queue if simulation uses a synchronized server clock
        if self.CLOCK_TYPE == SimClocks.SERVER_STEP:
            self.tic_request_queue = asyncio.Queue()
            self.tic_request_queue_sorted = []
            
    async def broadcast_sim_end(self):
        """
        Broadcasts a message announcing the end of the simulation to all agents subscribed to this environment. 
        All agents must aknowledge that they have received and processed this message for the simulation to end.
        """
        # broadcast simulation end to all subscribers
        msg_dict = dict()
        msg_dict['src'] = self.name
        msg_dict['dst'] = 'all'
        msg_dict['@type'] =  BroadcastTypes.SIM_END_EVENT.name
        msg_dict['server_clock'] = time.perf_counter() - self.START_TIME
        kill_msg = json.dumps(msg_dict)

        t = msg_dict['server_clock']
        self.message_logger.debug(f'Broadcasting simulation end at t={t}[s]')
        self.log(f'Broadcasting simulation end at t={t}[s]')
        
        await self.publisher.send_json(kill_msg)

        # wait for all agents to send their confirmation
        self.request_logger.info(f'Waiting for simulation end confirmation from {len(self.AGENT_NAME_LIST)} agents...')
        self.log(f'Waiting for simulation end confirmation from {len(self.AGENT_NAME_LIST)} agents...', level=logging.INFO)
        while len(self.offline_subscribers) < self.NUMBER_AGENTS:
            # wait for synchronization request
            msg_str = await self.reqservice.recv_json() 
            self.reqservice.send_string('')
            msg_dict = json.loads(msg_str)
            msg_src = msg_dict['src']
            msg_type = msg_dict['@type']

            if RequestTypes[msg_type] is not RequestTypes.AGENT_END_CONFIRMATION:
                # if request is not of the type end-of-simulation, then discard and wait for the next
                continue
            
            self.request_logger.info(f'Received simulation end confirmation from {msg_src}!')
            self.log(f'Received simulation end confirmation from {msg_src}!', level=logging.INFO)
            
            # log subscriber confirmation
            for agent_name in self.AGENT_NAME_LIST:
                if agent_name in msg_src and not agent_name in self.offline_subscribers:
                    self.offline_subscribers.append(agent_name)
                    self.log(f"{agent_name} has ended its processes ({len(self.offline_subscribers)}/{self.NUMBER_AGENTS}).", level=logging.INFO)
                    break

    def set_up_results_directory(self, scenario_dir):
        scenario_results_path = scenario_dir + '/results'
        if not os.path.exists(scenario_results_path):
            # if directory does not exists, create it
            os.mkdir(scenario_results_path)

        enviroment_results_path = scenario_results_path + f'/{self.name}'
        if os.path.exists(enviroment_results_path):
            # if directory already exists, cleare contents
            for f in os.listdir(enviroment_results_path):
                os.remove(os.path.join(enviroment_results_path, f)) 
        else:
            # if directory does not exist, create a new onw
            os.mkdir(enviroment_results_path)

        return scenario_results_path, enviroment_results_path


    def set_up_loggers(self):
        # set root logger to default settings
        logging.root.setLevel(logging.NOTSET)
        logging.basicConfig(level=logging.NOTSET)

        logger_names = ['messages', 'requests', 'state', 'actions']

        loggers = []
        for logger_name in logger_names:
            path = self.ENVIRONMENT_RESULTS_DIR + f'/{logger_name}.log'

            if os.path.isdir(path):
                # if file already exists, delete
                os.remove(path)

            # create logger
            logger = logging.getLogger(f'{self.name}_{logger_name}')
            logger.propagate = False

            # create handlers
            c_handler = logging.StreamHandler()
            if logger_name == 'actions':
                c_handler.setLevel(logging.DEBUG)
            else:
                c_handler.setLevel(logging.WARNING)

            f_handler = logging.FileHandler(path)
            f_handler.setLevel(logging.DEBUG)

            # add handlers to logger
            logger.addHandler(c_handler)
            logger.addHandler(f_handler)

            loggers.append(logger)
        return loggers

    async def submit_tic_request(self, delay, module_name):
        # if the clock is server-step, then submit a tic request to environment
        t_end = self.sim_time.level + delay

        self.log(f'Submitting tic-request for t_end={t_end}.', module_name=module_name)

        req_msg = RequestTypes.create_tic_event_message(self.name, EnvironmentModuleTypes.TIC_REQUEST_MODULE.name, t_end)

        await self.put_message(req_msg)
        
"""
--------------------
MAIN
--------------------    
"""
if __name__ == '__main__':
    print('Initializing environment...')
    scenario_dir = './scenarios/sim_test/'
    duration = 6048

    # environment = EnvironmentServer('ENV', scenario_dir, ['AGENT0'], 5, clock_type=SimClocks.REAL_TIME)
    environment = EnvironmentServer(scenario_dir, ['Mars1'], duration, clock_type=SimClocks.SERVER_STEP)
    
    asyncio.run(environment.live())


### messages

from abc import abstractclassmethod
from enum import Enum


class MessageTypes(Enum):
    @abstractclassmethod
    def format_check(msg: dict):
        """
        Checks if a message of type request contains the proper contents and format.
        Returns a boolean that indicates if this message meets these criterea.
        """
        pass

class BroadcastTypes(Enum):
    """
    Types of broadcasts sent from the environemnt to all agents.
        1- tic: informs all agents of environment server's current time
        2- eclipse_event: informs agents that an agent has entered eclipse. agents must ignore transmission if they are not the agent affected by the event
        3- sim_start: notifies all agents that the simulation has started
        4- sim_end: notifies all agents that the simulation has ended 
    """
    TIC_EVENT = 'TIC_EVENT'
    ECLIPSE_EVENT = 'ECLIPSE_EVENT'
    GP_ACCESS_EVENT = 'GP_ACCESS_EVENT'
    GS_ACCESS_EVENT = 'GS_ACCESS_EVENT'
    AGENT_ACCESS_EVENT = 'AGENT_ACCESS_EVENT'
    SIM_START_EVENT = 'SIM_START_EVENT'
    SIM_END_EVENT = 'SIM_END_EVENT'

    def format_check(msg: dict):
        """
        Checks if a message of type request contains the proper contents and format.
        Returns a boolean that indicates if this message meets these criterea.
        """

        msg_src = msg.get('src', None)
        msg_dst = msg.get('dst', None)
        msg_type = msg.get('@type', None)

        if msg_src is None or msg_dst is None or msg_type is None:
            # any message must contain a source, destination, and type.
            return False
        
        if BroadcastTypes[msg_type] is BroadcastTypes.TIC_EVENT:
            t = msg.get('server_clock', None)
            
            if t is None:
                # tic broadcasts must contain current server time
                return False
        elif BroadcastTypes[msg_type] is BroadcastTypes.SIM_START_EVENT or BroadcastTypes[msg_type] is BroadcastTypes.SIM_END_EVENT:
            return True
        elif (BroadcastTypes[msg_type] is BroadcastTypes.ECLIPSE_EVENT 
                or BroadcastTypes[msg_type] is BroadcastTypes.GS_ACCESS_EVENT
                or BroadcastTypes[msg_type] is BroadcastTypes.AGENT_ACCESS_EVENT):
            return True
        else:
            return False
        
        return True

    def create_eclipse_event_broadcast(src: str, dst: str, agent_name: str, rise: bool, t: float) -> dict:
        msg_dict = dict()

        msg_dict['src'] = src
        msg_dict['dst'] = dst
        msg_dict['@type'] = BroadcastTypes.ECLIPSE_EVENT.name
        msg_dict['server_clock'] = t
        msg_dict['agent'] = agent_name
        msg_dict['rise'] = rise

        return msg_dict

    def create_gs_access_event_broadcast(src: str, dst: str, agent_name: str, rise: bool, t: float, 
                                        gndStat_name: str, gndStat_id: str, lat: float, lon: float) -> dict:
        msg_dict = dict()

        msg_dict['src'] = src
        msg_dict['dst'] = dst
        msg_dict['@type'] = BroadcastTypes.GS_ACCESS_EVENT.name
        msg_dict['server_clock'] = t
        msg_dict['agent'] = agent_name
        msg_dict['rise'] = rise
        msg_dict['gndStat_name'] = gndStat_name
        msg_dict['gndStat_id'] = gndStat_id
        msg_dict['lat'] = lat
        msg_dict['lon'] = lon

        return msg_dict

    def create_agent_access_event_broadcast(src: str, dst: str, rise: bool, t: float, agent_name: str, target: str) -> dict:
        msg_dict = dict()

        msg_dict['src'] = src
        msg_dict['dst'] = dst
        msg_dict['@type'] = BroadcastTypes.AGENT_ACCESS_EVENT.name
        msg_dict['server_clock'] = t
        msg_dict['rise'] = rise
        msg_dict['agent'] = agent_name
        msg_dict['target'] = target

        return msg_dict

class RequestTypes(Enum):
    """
    Types of requests between agents and environment.
        0- sync_request: agent notifies environment server that it is online and ready to start the simulation. Only used before the start of the simulation
        1- tic_request: agents ask to be notified when a certain time has passed in the environment's clock    
        2- agent_access_request: agent asks the enviroment if the agent is capable of accessing another agent at the current simulation time
        3- gp_access_request: agent asks the enviroment if the agent is capable of accessing a ground point at the current simulation time
        4- gs_access_request: agent asks the enviroment if the agent is capable of accessing a ground station at the current simulation time
        5- agent_information_request: agent asks for information regarding its current position, velocity, and eclipse at the current simulation time
        6- observation_request: agent requests environment information regarding a the state of a ground point at the current simulation time
        7- agent_end_confirmation: agent notifies the environment that it has successfully terminated its operations
    """
    SYNC_REQUEST = 'SYNC_REQUEST'
    TIC_REQUEST = 'TIC_REQUEST'
    AGENT_ACCESS_REQUEST = 'AGENT_ACCESS_REQUEST'
    GP_ACCESS_REQUEST = 'GROUND_POINT_ACCESS_REQUEST'
    GS_ACCESS_REQUEST = 'GROUND_STATION_ACCESS_REQUEST'
    AGENT_INFO_REQUEST = 'AGENT_INFO_REQUEST'
    OBSERVATION_REQUEST = 'OBSERVATION_REQUEST'
    AGENT_END_CONFIRMATION = 'AGENT_END_CONFIRMATION'

    def format_check(msg: dict):
        """
        Checks if a message of type request contains the proper contents and format.
        Returns a boolean that indicates if this message meets these criterea.
        """

        msg_src = msg.get('src', None)
        msg_dst = msg.get('dst', None)
        msg_type = msg.get('@type', None)

        if msg_src is None or msg_dst is None or msg_type is None:
            # any message must contain a source, destination, and type.
            return False
        
        if RequestTypes[msg_type] is RequestTypes.SYNC_REQUEST:
            port = msg.get('port', None)
            n_coroutines = msg.get('n_coroutines', None)

            if port is None or n_coroutines is None or n_coroutines < 0:
                # sync requests must contain 
                return False
        elif RequestTypes[msg_type] is RequestTypes.TIC_REQUEST:
            t_end = msg.get('t', None)
            
            if t_end is None:
                return False
        elif RequestTypes[msg_type] is RequestTypes.AGENT_ACCESS_REQUEST:
            pass
        elif RequestTypes[msg_type] is RequestTypes.AGENT_INFO_REQUEST:
            pass
        elif RequestTypes[msg_type] is RequestTypes.OBSERVATION_REQUEST:
            pass
        elif RequestTypes[msg_type] is RequestTypes.AGENT_END_CONFIRMATION:
            return True
        else:
            return False
        
        return True
    
    def create_tic_event_message(src: str, dst: str, t: float):
        tic_msg = dict()
        tic_msg['src'] = src
        tic_msg['dst'] = dst
        tic_msg['@type'] = RequestTypes.TIC_REQUEST.name
        tic_msg['t'] = t

        return tic_msg

#### AGENT

import asyncio
from curses import def_prog_mode
import json
import os
import random
import sys
import time
import zmq
import zmq.asyncio
import logging
from environment import EnvironmentServer
from messages import BroadcastTypes
from utils import SimClocks, Container
from messages import RequestTypes

from modules.module import Module

"""    
--------------------------------------------------------
 ______                         __        ____    ___                       __      
/\  _  \                       /\ \__    /\  _`\ /\_ \    __               /\ \__   
\ \ \L\ \     __      __    ___\ \ ,_\   \ \ \/\_\//\ \  /\_\     __    ___\ \ ,_\  
 \ \  __ \  /'_ `\  /'__`\/' _ `\ \ \/    \ \ \/_/_\ \ \ \/\ \  /'__`\/' _ `\ \ \/  
  \ \ \/\ \/\ \L\ \/\  __//\ \/\ \ \ \_    \ \ \L\ \\_\ \_\ \ \/\  __//\ \/\ \ \ \_ 
   \ \_\ \_\ \____ \ \____\ \_\ \_\ \__\    \ \____//\____\\ \_\ \____\ \_\ \_\ \__\
    \/_/\/_/\/___L\ \/____/\/_/\/_/\/__/     \/___/ \/____/ \/_/\/____/\/_/\/_/\/__/
              /\____/                                                               
              \_/__/
 __  __              __            
/\ \/\ \            /\ \           
\ \ `\\ \    ___    \_\ \     __   
 \ \ , ` \  / __`\  /'_` \  /'__`\ 
  \ \ \`\ \/\ \L\ \/\ \L\ \/\  __/ 
   \ \_\ \_\ \____/\ \___,_\ \____\
    \/_/\/_/\/___/  \/__,_ /\/____/                                                                                                                                                 
--------------------------------------------------------
"""

def is_port_in_use(port: int) -> bool:
    import socket
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex(('localhost', port)) == 0

def get_next_available_port():
    port = 5555
    while is_port_in_use(port):
        port += 1
    return port

def count_number_of_subroutines(module: Module):
        count = module.NUMBER_OF_TIMED_COROUTINES
        for submodule in module.submodules:
            count += count_number_of_subroutines(submodule)
        return count

class AgentNode(Module):
    def __init__(self, name, scenario_dir, modules=[], env_port_number = '5561', env_request_port_number = '5562') -> None:
        super().__init__(name, submodules=modules, n_timed_coroutines=0)
        
        # set up results dir
        self.SCENARIO_RESULTS_DIR, self.AGENT_RESULTS_DIR = self.set_up_results_directory(scenario_dir)

        # set up loggers
        self.message_logger, self.env_request_logger, self.measurement_logger, self.state_logger, self.actions_logger = self.set_up_loggers()
        
        # Network information
        self.ENVIRONMENT_PORT_NUMBER =  env_port_number
        self.REQUEST_PORT_NUMBER = env_request_port_number
        self.AGENT_TO_PORT_MAP = None
        
        self.log('Agent Initialized!', level=logging.INFO)

    async def live(self):
        """
        MAIN FUNCTION 
        executes event loop for ayncronous processes within the agent
        """
        # Activate 
        await self.activate()

        # Run simulation
        await self.run()

    async def activate(self):
        """
        Initiates and executes commands that are thread-sensitive but that must be performed before the simulation starts.
        """
        self.log(f'Starting activation routine...', level=logging.INFO)

        # initiate network ports and connect to environment server
        self.log('Configuring network ports...')
        await self.network_config()
        self.log('Network configuration completed!')

        # confirm online status to environment server 
        self.log("Synchronizing with environment...")
        await self.sync_environment()
        self.log(f'Synchronization response received! Synchronized with environment.')

        # await for start-simulation message from environment
        self.log(f'Waiting for simulation start broadcast...')
        await self.wait_sim_start()
        self.log(f'Simulation start broadcast received!')

        self.log(f'Activating agent submodules...')
        await super().activate()
        self.log('Agent activated!', level=logging.INFO)

    async def run(self):        
        """
        Performs simulation actions.

        Runs every module owned by the agent. Stops when one of the modules goes off-line, completes its run() routines, 
        or the environment sends a simulation end broadcast.
        """  
        # begin simulation
        self.log(f"Starting simulation...", level=logging.INFO)
        await super().run()

    async def shut_down(self):
        """
        Terminate processes 
        """
        self.log(f"Shutting down agent...", level=logging.INFO)
        
        # send a reception confirmation
        self.env_request_logger.info('Connection to environment established!')
        end_msg = dict()
        end_msg['src'] = self.name
        end_msg['dst'] = EnvironmentServer.ENVIRONMENT_SERVER_NAME.value
        end_msg['@type'] = RequestTypes.AGENT_END_CONFIRMATION.name
        end_json = json.dumps(end_msg)

        await self.environment_request_socket.send_json(end_json)
        self.env_request_logger.info('Agent termination aknowledgement sent. Awaiting environment response...')

        # wait for server reply
        await self.environment_request_socket.recv() 
        self.env_request_logger.info('Response received! terminating agent.')

        self.log(f"Closing all network sockets...")
        self.agent_socket_in.close()
        self.context.destroy()
        self.log(f"Network sockets closed.", level=logging.INFO)

        self.log(f'...Good Night!', level=logging.INFO)

    """
    --------------------
    CO-ROUTINES AND TASKS
    --------------------
    """
    async def internal_message_handler(self, msg):
        """
        Handles message intended for this module and performs actions accordingly.
        """
        try:
            dst_name = msg['dst']
            if dst_name != self.name:
                await self.put_message(msg)
            else:
                msg_type = msg['@type']
                if msg_type == 'PRINT':
                    content = msg['content']
                    self.log(content)                
                elif msg_type is RequestTypes.AGENT_ACCESS_REQUEST:
                    src_module = msg['src'] 
                    msg['src'] = self.name
                    msg['dst'] = EnvironmentServer.ENVIRONMENT_SERVER_NAME

                    msg_json = json.loads(msg)
                    await self.environment_request_lock.acquire()
                    resp = await self.environment_request_socket.send_json(msg)
                    self.environment_request_lock.release()
                    x = 1

        except asyncio.CancelledError:
            return

    async def coroutines(self):
        try:
            broadcast_reception_handler = asyncio.create_task(self.broadcast_reception_handler())
            await broadcast_reception_handler   
        except asyncio.CancelledError:
            broadcast_reception_handler.cancel()
            await broadcast_reception_handler
            return
    
    async def broadcast_reception_handler(self):
        """
        Listens for broadcasts from the environment. Stops processes when simulation end-command is received.
        """
        try:
            while True:
                msg_string = await self.environment_broadcast_socket.recv_json()
                msg_dict = json.loads(msg_string)

                src = msg_dict['src']
                dst = msg_dict['dst']
                msg_type = msg_dict['@type']
                t_server = msg_dict['server_clock']

                self.message_logger.info(f'Received message of type {msg_type} from {src} intended for {dst} with server time of t={t_server}!')

                msg_type = BroadcastTypes[msg_type]

                if msg_type is BroadcastTypes.SIM_END_EVENT:
                    self.log('Simulation end broadcast received! Terminating agent...', level=logging.INFO)
                    return

                elif msg_type is BroadcastTypes.TIC_EVENT:
                    if (self.CLOCK_TYPE == SimClocks.SERVER_STEP 
                        or self.CLOCK_TYPE == SimClocks.SERVER_TIME
                        or self.CLOCK_TYPE == SimClocks.SERVER_TIME_FAST):
                        
                        # use server clock broadcasts to update internal clock
                        self.message_logger.info(f'Updating internal clock.')
                        await self.sim_time.set_level(t_server)
                        self.log('Updated internal clock.')
                else:
                    self.log(f'Broadcasts of type {msg_type.name} not yet supported.')
        except asyncio.CancelledError:
            return

    """
    --------------------
    HELPING FUNCTIONS
    --------------------    
    """
    async def network_config(self):
        """
        Creates communication sockets and connects this agent to them.

        'environment_broadcast_socket': listens for broadcasts coming from the environment
        'environment_request_socket': used to request and receive information directly from the environment
        'agent_socket_in': conects to other agents. Receives requests for information from others
        'agent_socket_out': connects to other agents. Sends information to others
        """ 
        self.context = zmq.asyncio.Context() 

        # subscribe to environment broadcasting port
        self.environment_broadcast_socket = self.context.socket(zmq.SUB)
        self.environment_broadcast_socket.connect(f"tcp://localhost:{self.ENVIRONMENT_PORT_NUMBER}")
        self.environment_broadcast_socket.setsockopt(zmq.SUBSCRIBE, b'')
        
        # give environment time to set up
        time.sleep(random.random())

        # connect to environment request port
        self.environment_request_socket = self.context.socket(zmq.REQ)
        self.environment_request_socket.connect(f"tcp://localhost:{self.REQUEST_PORT_NUMBER}")
        self.environment_request_lock = asyncio.Lock()

        # create agent communication sockets
        self.agent_socket_in = self.context.socket(zmq.REP)
        self.agent_port_in = get_next_available_port()
        self.agent_socket_in.bind(f"tcp://*:{self.agent_port_in}")

        self.agent_socket_out = self.context.socket(zmq.REQ)

    async def sync_environment(self):
        """
        Cend a synchronization request to environment server
        """
        self.log('Connection to environment established!')
        await self.environment_request_lock.acquire()

        sync_msg = dict()
        sync_msg['src'] = self.name
        sync_msg['dst'] = EnvironmentServer.ENVIRONMENT_SERVER_NAME
        sync_msg['@type'] = RequestTypes.SYNC_REQUEST.name
        sync_msg['port'] = self.agent_port_in
        sync_msg['n_coroutines'] = count_number_of_subroutines(self)
        sync_json = json.dumps(sync_msg)

        await self.environment_request_socket.send_json(sync_json)
        self.log('Synchronization request sent. Awaiting environment response...')

        # wait for synchronization reply
        await self.environment_request_socket.recv()  
        self.environment_request_lock.release()

    async def wait_sim_start(self):
        """
        Awaits for simulation start message from the environment. 
        This message contains a ledger that maps agent names to ports to be connected to for inter-agent communications. 
        The message also contains information about the clock-type being used in this simulation.
        """
        # await for start message 
        start_msg = await self.environment_broadcast_socket.recv_json()

        # log simulation start time
        self.START_TIME = time.perf_counter()

        # register agent-to-port map
        start_dict = json.loads(start_msg)
        agent_to_port_map = start_dict['port_map']
        self.AGENT_TO_PORT_MAP = dict()
        for agent in agent_to_port_map:
            self.AGENT_TO_PORT_MAP[agent] = agent_to_port_map[agent]
        self.log(f'Agent to port map received: {self.AGENT_TO_PORT_MAP}')

        # setup clock information
        clock_info = start_dict['clock_info']
        self.CLOCK_TYPE = SimClocks[clock_info['@type']]

        if self.CLOCK_TYPE == SimClocks.REAL_TIME or self.CLOCK_TYPE == SimClocks.REAL_TIME_FAST:
            self.SIMULATION_FREQUENCY = clock_info['freq']
            self.sim_time = 0
        else:
            self.SIMULATION_FREQUENCY = None
            self.sim_time = Container()

    def set_up_results_directory(self, scenario_dir):
        """
        Creates directories for agent results and clears them if they already exist
        """

        scenario_results_path = scenario_dir + '/results'
        if not os.path.exists(scenario_results_path):
            # if directory does not exists, create it
            os.mkdir(scenario_results_path)

        agent_results_path = scenario_results_path + f'/{self.name}'
        if os.path.exists(agent_results_path):
            # if directory already exists, clear contents
            for f in os.listdir(agent_results_path):
                os.remove(os.path.join(agent_results_path, f)) 
        else:
            # if directory does not exist, create a new onw
            os.mkdir(agent_results_path)

        return scenario_results_path, agent_results_path

    def set_up_loggers(self):
        """
        set root logger to default settings
        """

        logging.root.setLevel(logging.NOTSET)
        logging.basicConfig(level=logging.NOTSET)
        
        logger_names = ['agent_messages', 'env_requests', 'measurements', 'state', 'actions']

        loggers = []
        for logger_name in logger_names:
            path = self.AGENT_RESULTS_DIR + f'/{logger_name}.log'

            if os.path.exists(path):
                # if file already exists, delete
                os.remove(path)

            # create logger
            logger = logging.getLogger(f'{self.name}_{logger_name}')
            logger.propagate = False

            # create handlers
            c_handler = logging.StreamHandler(sys.stderr)

            if logger_name == 'actions':
                c_handler.setLevel(logging.DEBUG)
            else:
                c_handler.setLevel(logging.WARNING)

            f_handler = logging.FileHandler(path)
            f_handler.setLevel(logging.DEBUG)

            # create formatters
            f_format = logging.Formatter('%(message)s')
            f_handler.setFormatter(f_format)

            # add handlers to logger
            logger.addHandler(c_handler)
            logger.addHandler(f_handler)

            loggers.append(logger)
        return loggers
        
    async def submit_tic_request(self, delay, module_name):
        t_end = self.sim_time.level + delay
        
        self.log(f'Sending tic request for t_end={t_end}. Awaiting access to environment request port...', module_name=module_name)
        await self.environment_request_lock.acquire()

        tic_msg = RequestTypes.create_tic_event_message(self.name, 'ENV', t_end)
        tic_json = json.dumps(tic_msg)

        await self.environment_request_socket.send_json(tic_json)
        self.log('Tic request sent successfully. Awaiting confirmation...', module_name=module_name)

        # wait for synchronization reply
        await self.environment_request_socket.recv()  
        self.environment_request_lock.release()
        self.log('Tic request reception confirmation received.', module_name=module_name)

class AgentState:
    def __init__(self, agent: AgentNode, component_list) -> None:
        pass

"""
--------------------
  TESTING AGENTS
--------------------
"""
class TestAgent(AgentNode):    
    def __init__(self, scenario_dir) -> None:
        super().__init__('Mars1', scenario_dir)
        self.submodules = [TestModule(self)]  

"""
--------------------
  TESTING MODULES
--------------------
"""
class SubModule(Module):
    def __init__(self, name, parent_module) -> None:
        super().__init__(name, parent_module, submodules=[])

    async def coroutines(self):
        try:
            self.log('Starting periodic print routine...')
            while True:
                msg = dict()
                msg['src'] = self.name
                msg['dst'] = self.parent_module.name
                msg['@type'] = 'PRINT'
                msg['content'] = 'TEST_PRINT'

                await self.parent_module.put_message(msg)

                # await self.sim_wait(1)

                # msg = dict()
                # msg['src'] = self.name
                # msg['dst'] = self.parent_module.parent_module.name
                # msg['@type'] = RequestTypes.AGENT_ACCESS_REQUEST
                # msg['target'] = 'Mars2'

                # await self.parent_module.put_message(msg)

                await self.sim_wait(20)
                
        except asyncio.CancelledError:
            self.log('Periodic print routine cancelled')
            return

class TestModule(Module):
    def __init__(self, parent_agent) -> None:
        super().__init__('test', parent_agent, [SubModule('sub_test', self)])

"""
--------------------
MAIN
--------------------    
"""
if __name__ == '__main__':
    print('Initializing agent...')
    scenario_dir = './scenarios/sim_test'
    
    agent = TestAgent(scenario_dir)
    
    asyncio.run(agent.live())